<?php
// Real Vulnerability Scanner - Backend cho penetration_tester_simple.php
header('Content-Type: application/json');
header('Access-Control-Allow-Origin: *');
header('Access-Control-Allow-Methods: POST, GET, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type');

if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    exit(0);
}

class RealVulnerabilityScanner {
    private $basePath;
    private $results = [];
    private $totalFiles = 0;
    private $scannedFiles = 0;
    
    public function __construct($basePath = __DIR__) {
        $this->basePath = realpath($basePath);
    }
    
    public function scan($directory = 'all', $scanType = 'full') {
        $response = [
            'status' => 'scanning',
            'phase' => 1,
            'message' => 'Bắt đầu quét bảo mật...',
            'progress' => 0,
            'vulnerabilities' => [],
            'stats' => [
                'files_scanned' => 0,
                'vulnerabilities' => 0,
                'critical_issues' => 0,
                'security_score' => 100
            ]
        ];
        
        try {
            // Phase 1: File Discovery
            $files = $this->discoverFiles($directory);
            $this->totalFiles = count($files);
            
            $response['phase'] = 2;
            $response['message'] = "Tìm thấy {$this->totalFiles} files để quét";
            $response['progress'] = 20;
            
            // Phase 2: Vulnerability Scanning
            foreach ($files as $file) {
                $vulns = $this->scanFile($file, $scanType);
                $this->results = array_merge($this->results, $vulns);
                $this->scannedFiles++;
                
                // Calculate progress (20% to 90%)
                $progress = 20 + (($this->scannedFiles / $this->totalFiles) * 70);
                $response['progress'] = round($progress);
            }
            
            // Phase 3: Generate Report
            $response['phase'] = 3;
            $response['message'] = 'Tạo báo cáo bảo mật...';
            $response['progress'] = 95;
            
            $response['vulnerabilities'] = $this->results;
            $response['stats'] = $this->calculateStats();
            $response['progress'] = 100;
            $response['message'] = 'Quét hoàn tất!';
            $response['status'] = 'completed';
            
        } catch (Exception $e) {
            $response['status'] = 'error';
            $response['message'] = 'Lỗi quét: ' . $e->getMessage();
        }
        
        return $response;
    }
    
    private function discoverFiles($directory) {
        $files = [];
        $scanDirs = [];
        
        switch ($directory) {
            case 'admin':
                $scanDirs = ['admin/'];
                break;
            case 'sources':
                $scanDirs = ['sources/'];
                break;
            case 'all':
            default:
                $scanDirs = ['admin/', 'sources/'];
                break;
        }
        
        foreach ($scanDirs as $dir) {
            $fullPath = $this->basePath . '/' . $dir;
            if (is_dir($fullPath)) {
                $files = array_merge($files, $this->scanDirectory($fullPath, $dir));
            }
        }
        
        return $files;
    }
    
    private function scanDirectory($path, $prefix = '') {
        $files = [];
        $iterator = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($path, RecursiveDirectoryIterator::SKIP_DOTS),
            RecursiveIteratorIterator::SELF_FIRST
        );
        
        foreach ($iterator as $file) {
            if ($file->isFile() && $file->getExtension() === 'php') {
                $relativePath = $prefix . substr($file->getPathname(), strlen($this->basePath) + 1);
                $files[] = [
                    'path' => $relativePath,
                    'fullPath' => $file->getPathname(),
                    'size' => $file->getSize()
                ];
            }
        }
        
        return $files;
    }
    
    private function scanFile($file, $scanType) {
        $vulnerabilities = [];
        $content = @file_get_contents($file['fullPath']);
        
        if (!$content) {
            return $vulnerabilities;
        }
        
        $lines = explode("\n", $content);
        
        // Scan for different vulnerability types
        switch ($scanType) {
            case 'full':
                $vulnerabilities = array_merge(
                    $vulnerabilities,
                    $this->scanSQLInjection($file, $lines),
                    $this->scanFileUpload($file, $lines),
                    $this->scanLFI($file, $lines),
                    $this->scanRCE($file, $lines),
                    $this->scanXSS($file, $lines)
                );
                break;
            case 'sqli':
                $vulnerabilities = $this->scanSQLInjection($file, $lines);
                break;
            case 'files':
                $vulnerabilities = $this->scanFileUpload($file, $lines);
                break;
            case 'lfi':
                $vulnerabilities = $this->scanLFI($file, $lines);
                break;
            case 'rce':
                $vulnerabilities = $this->scanRCE($file, $lines);
                break;
        }
        
        return $vulnerabilities;
    }
    
    private function scanSQLInjection($file, $lines) {
        $vulnerabilities = [];
        $patterns = [
            '/\$d->.*\(.*\$_(GET|POST|REQUEST|SESSION)\[/' => 'Direct user input in database query',
            '/SELECT.*\$_(GET|POST|REQUEST|SESSION)\[/' => 'SQL query with user input',
            '/INSERT.*\$_(GET|POST|REQUEST|SESSION)\[/' => 'INSERT query with user input',
            '/UPDATE.*\$_(GET|POST|REQUEST|SESSION)\[/' => 'UPDATE query with user input',
            '/DELETE.*\$_(GET|POST|REQUEST|SESSION)\[/' => 'DELETE query with user input'
        ];
        
        foreach ($lines as $lineNum => $line) {
            foreach ($patterns as $pattern => $description) {
                if (preg_match($pattern, $line)) {
                    $vulnerabilities[] = [
                        'type' => 'SQL Injection',
                        'file' => $file['path'],
                        'line' => $lineNum + 1,
                        'severity' => 'critical',
                        'description' => $description,
                        'code' => trim($line),
                        'timestamp' => date('Y-m-d H:i:s')
                    ];
                }
            }
        }
        
        return $vulnerabilities;
    }
    
    private function scanFileUpload($file, $lines) {
        $vulnerabilities = [];
        $patterns = [
            '/move_uploaded_file\s*\(/' => 'File upload without validation',
            '/\$_FILES\[.*\]\[\'tmp_name\'\]/' => 'Direct file upload handling',
            '/copy\s*\(\s*\$_FILES/' => 'File copy without validation'
        ];
        
        foreach ($lines as $lineNum => $line) {
            foreach ($patterns as $pattern => $description) {
                if (preg_match($pattern, $line)) {
                    // Check if line contains validation
                    $hasValidation = preg_match('/(pathinfo|getimagesize|is_uploaded_file|mime_content_type)/', $line);
                    
                    if (!$hasValidation) {
                        $vulnerabilities[] = [
                            'type' => 'File Upload Vulnerability',
                            'file' => $file['path'],
                            'line' => $lineNum + 1,
                            'severity' => 'critical',
                            'description' => $description,
                            'code' => trim($line),
                            'timestamp' => date('Y-m-d H:i:s')
                        ];
                    }
                }
            }
        }
        
        return $vulnerabilities;
    }
    
    private function scanLFI($file, $lines) {
        $vulnerabilities = [];
        $patterns = [
            '/include\s*\(.*\$_(GET|POST|REQUEST|SESSION)\[/' => 'Local File Inclusion via include',
            '/require\s*\(.*\$_(GET|POST|REQUEST|SESSION)\[/' => 'Local File Inclusion via require',
            '/include_once\s*\(.*\$_(GET|POST|REQUEST|SESSION)\[/' => 'Local File Inclusion via include_once',
            '/require_once\s*\(.*\$_(GET|POST|REQUEST|SESSION)\[/' => 'Local File Inclusion via require_once'
        ];
        
        foreach ($lines as $lineNum => $line) {
            foreach ($patterns as $pattern => $description) {
                if (preg_match($pattern, $line)) {
                    $vulnerabilities[] = [
                        'type' => 'Local File Inclusion',
                        'file' => $file['path'],
                        'line' => $lineNum + 1,
                        'severity' => 'high',
                        'description' => $description,
                        'code' => trim($line),
                        'timestamp' => date('Y-m-d H:i:s')
                    ];
                }
            }
        }
        
        return $vulnerabilities;
    }
    
    private function scanRCE($file, $lines) {
        $vulnerabilities = [];
        $patterns = [
            '/eval\s*\(/' => 'Code execution via eval()',
            '/exec\s*\(/' => 'Code execution via exec()',
            '/system\s*\(/' => 'Code execution via system()',
            '/shell_exec\s*\(/' => 'Code execution via shell_exec()',
            '/passthru\s*\(/' => 'Code execution via passthru()',
            '/base64_decode\s*\(.*\$_(GET|POST|REQUEST)/' => 'Potential code injection via base64_decode'
        ];
        
        foreach ($lines as $lineNum => $line) {
            foreach ($patterns as $pattern => $description) {
                if (preg_match($pattern, $line)) {
                    $vulnerabilities[] = [
                        'type' => 'Remote Code Execution',
                        'file' => $file['path'],
                        'line' => $lineNum + 1,
                        'severity' => 'critical',
                        'description' => $description,
                        'code' => trim($line),
                        'timestamp' => date('Y-m-d H:i:s')
                    ];
                }
            }
        }
        
        return $vulnerabilities;
    }
    
    private function scanXSS($file, $lines) {
        $vulnerabilities = [];
        $patterns = [
            '/echo\s+\$_(GET|POST|REQUEST|SESSION)\[/' => 'Potential XSS via direct echo',
            '/print\s+\$_(GET|POST|REQUEST|SESSION)\[/' => 'Potential XSS via direct print',
            '/<\?=\s*\$_(GET|POST|REQUEST|SESSION)\[/' => 'Potential XSS via short echo tag'
        ];
        
        foreach ($lines as $lineNum => $line) {
            foreach ($patterns as $pattern => $description) {
                if (preg_match($pattern, $line)) {
                    // Check if output is sanitized
                    $hasSanitization = preg_match('/(htmlspecialchars|htmlentities|strip_tags|addslashes)/', $line);
                    
                    if (!$hasSanitization) {
                        $vulnerabilities[] = [
                            'type' => 'Cross-Site Scripting (XSS)',
                            'file' => $file['path'],
                            'line' => $lineNum + 1,
                            'severity' => 'medium',
                            'description' => $description,
                            'code' => trim($line),
                            'timestamp' => date('Y-m-d H:i:s')
                        ];
                    }
                }
            }
        }
        
        return $vulnerabilities;
    }
    
    private function calculateStats() {
        $critical = 0;
        $high = 0;
        $medium = 0;
        $low = 0;
        
        foreach ($this->results as $vuln) {
            switch ($vuln['severity']) {
                case 'critical': $critical++; break;
                case 'high': $high++; break;
                case 'medium': $medium++; break;
                case 'low': $low++; break;
            }
        }
        
        $totalVulns = count($this->results);
        $securityScore = max(0, 100 - ($critical * 25) - ($high * 15) - ($medium * 10) - ($low * 5));
        
        return [
            'files_scanned' => $this->scannedFiles,
            'vulnerabilities' => $totalVulns,
            'critical_issues' => $critical,
            'security_score' => $securityScore,
            'breakdown' => [
                'critical' => $critical,
                'high' => $high,
                'medium' => $medium,
                'low' => $low
            ]
        ];
    }
}

// Main execution
if ($_SERVER['REQUEST_METHOD'] === 'GET') {
    $directory = $_GET['directory'] ?? 'all';
    $scanType = $_GET['type'] ?? 'full';
    
    $scanner = new RealVulnerabilityScanner();
    $result = $scanner->scan($directory, $scanType);
    
    echo json_encode($result, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);
} else {
    http_response_code(405);
    echo json_encode(['error' => 'Method not allowed']);
}
?> 